% Dokumenteinstellungen
% ======================================================================

% Die Dokumentklasse definiert die Art des Dokuments
% und seine Grundeigenschaften
\documentclass[11pt,a4paper]{scrartcl}		% [Schriftgröße 10, Textbereich Din A4] {Dokumentart Artikel}


% Zusätzliche (aber sinnvolle) Pakete laden
% ======================================================================
% Pekete fügen verschiedene Funktionen zu LaTeX hinzu.
% ganz ohne Pakete wäre Latex gerade mal etwas besser als notepad...
\usepackage[a4paper]{geometry}				% DIN-A4 Größe des Papiers; sollte mit der Ausdehnung des Textes in documetnclass übereinstimmen.
\usepackage[utf8]{inputenc}					% Zeichenkodierung UTF-8 falls Probleme wegen utf8 auftreten, utf8 durch utf8x ersetzen
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}						% erlaubt mathematische Formeln
\usepackage[english]{babel}					% Deutsche Sprache und Silbentrennung
\usepackage{amssymb}						% Verschiedene Symbole
\usepackage{graphicx}						% Zum Bilder einfügen benötigt
\usepackage{hyperref}						% Sprunglinks für Überschriften, Fußnoten und Weblinks

%Eigenes

\usepackage{subfig}							% Subfloat Benutzung, Unterteilung für Bilder

\usepackage[numbers,square]{natbib}
\bibliographystyle{alphadin}%plaindin}%unsrt}%alphadin}
\usepackage{gensymb}
\usepackage{setspace}
\usepackage{geometry}
\geometry{a4paper,left=2.5cm,right=2.5cm}

\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{eurosym}

\usepackage[shortlabels]{enumitem}

\usepackage{fixltx2e}  % Für \textsubscript{}

\usepackage{tabularx}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

\usepackage{longtable}

\usepackage{pdfpages}

\usepackage{pstricks}	% Erstellung von Plots
\usepackage{pst-plot}


% Dokumentbeginn
% ======================================================================
% Ab hier beginnt das eigentliche Dokument.
% Alles was danach folgt wird im fertigen PDF angezeigt.

\begin{document}


% Titelblatt
% ===========================================

\begin{titlepage}
	
	\singlespacing
	\begin{center}
	
		\quad
		\vspace{1cm}
	
		\Large{\textbf{Project Work\\Cyber-Physical Systems}}
	
		\vspace{1.5cm}
	
		\huge{\textbf{Autonomous Aerobatics on\\Commanded Paths}}
	
		\vspace{1.5cm}
	
		written by
		
		\vspace{1.5cm}
	
		\Large{\textbf{Youlin Gao\\Anthony Blanc\\Andreas Bruckmeier}}
	
		\vfill
		
		submitted at the\\
		Institute for Real-Time Computer Systems\\
		Technische Universität München,\\
		to\\
		Prof. Marco Caccamo

		\vspace{1cm}		
		
		Date: 7\textsuperscript{th} March 2016
	
	\end{center}
	
\end{titlepage}

\setstretch{1.2}


% Inhaltsverzeichnis   (Überschriften werden automatisch in das Inhaltsverzeichnis aufgenommen.)
% ===========================================
\newpage
\tableofcontents	

\vfill

% Abbildungsverzeichnis
% ===========================================

%\renewcommand{\listfigurename}{}
\listoffigures
%{\def\section*#1{}\listoffigures}


% Textbeginn
% ================================================================================
% ================================================================================


% Neue Seite
% ===========================================
\newpage
	

\section{Overview}

As a part of the Cyber-Physical Systems course in WS15/16, a controller structure for an aircraft in a simulation environment was realised, performing autonomous aerobatics on commanded paths.
In this report, the controller structure is presented in Chapter~\ref{ch_Details}, and performance results are shown in Chapter~\ref{ch-Results}.
Before this, an overview of the working principle and the features of the controller are given, and the underlying work is clarified.

\medskip






\subsection{Working Principle and Features}

Control target of the presented system is to follow a path as a function of time in 3-dimensional space.
The aircraft's aim is to fly along this commanded path by determining the deviation from the given trajectory and thereout calculating acceleration commands which are the inputs of the aircraft's actuator controllers.

\textbf{Figure~\ref{fig_complete_structure}} depicts the complete control structure of the aerobatic controller. 
With the position data from the desired trajectory and with actual position signals of the aircraft, the desired acceleration to follow the path is computed.
After considering the gravity, the desired acceleration is handed to the control structure where the acceleration in body frame is used as the control variable for the aileron-, elevator-, and rudder-controllers.
Also, with the position data, the delay of the aircraft from the desired position is determined, and by considering a \textsl{look ahead distance} which forces the aircraft to lag behind the path by a specific distance, the throttle is controlled with this information.

The resulting steering signals, computed by the control structure, are handed to the simulation environment which simulates the physical reaction of the aircraft and then hands back measurement results of its virtual sensors.
These signals are processed and provided to the control structure. 
A feature of the \texttt{Signal Processing} is the estimation of the aircraft's position with only accelerometers and gyrometers when there is no available GPS-signal as it is in inverted flight attitude.

\begin{figure}[!h]
  \begin{center}
  	\includegraphics[width=18.8cm, angle=90]{pictures/complete_structure.pdf}
  \end{center}
  \caption{Overview of the control structure of the aerobatic controller.}
  \label{fig_complete_structure}
\end{figure}


\subsection{Underlying Work}

The control structure, implemented and presented in this project work, is based on the work of Sanghyuk Park\cite{Park.2012} and modified by establishing the desired path depending on time plus determining the path delay in order to control the throttle.

The estimation of the aircraft's position signal is implemented after a method which is, at the time of handing in this report, not yet published. We got the access ahead of the release by our tutor \cite{Dantsker.2016}.

\medskip





\section{Details}\label{ch_Details}

In the following, each part of the control structure (compare Figure~\ref{fig_complete_structure}) is presented in detail.

\medskip





\subsection{Interface with the Simulation Environment}

The connection of our program with the simulation environment takes place at the beginning of each program run, when sensor data is handed over and at the end of each run, when commands for the actuators are given to the aircraft.

In the code, the function~\textsf{calculateStateVariables} reads the sensor data of the aircraft to our part of the software.
At the end of each program run, the four steering signals for the actuators throttle, aileron, rudder, and elevator are given to the simulation environment in the function~\textsf{generateOutSignals}.

\medskip




\subsection{User Interface}

We have implemented an user interface which enables a communication with the aircraft controller via an USB connection with the controller board. 
We used the program \texttt{hterm} for communicating with the controller over a COM-Port.

The interface enables the user to modify controller parameters and flight special pre-established paths at run time. Sending the lette \texttt{'h'} print help instruction and explaination how to use the interface.

All this path have been saved and are managed in a state machine in function~\textsf{trajectory.cpp}. Every state correspond to a different path. Here are this list of the possible paths:

\begin{itemize}
\item 
0.	Take off
\item
1.	Circle
\item
2.	Looping
\item
3.	Go streight / Glide
\item
4.	Roll		
\item	
5.	Glide back
\item
6.	Half circle
\item
7.	Climb up
\item
8.	Snake
\end{itemize}

We can sum up this state in the fallowing diagram:

\includegraphics[scale=0.3]{picture/StateDiagramme_liason.gif}

As you can see on the diagram, some states are unstable are limited during the time. The arrow indicates the direct next state. For more detail about the path, report direclty to the concerning section. To go from one state to an other, the user has to tipp the fallowing command: 

\begin{itemize}
\item 
ft - Take off 
\item
fc - Circle 
\item
fl - Looping
\item
fg - Go streight / Glide
\item
fr - Roll		
\item	
fb - Glide back
\item
fh - Half circle
\item
fc - Climb up
\item
fs - Snake
\end{itemize}

Note: 'f' is for flying and all the second letter are correspond to the state name.

The API allowed us to edit some variables. It includes only the PID and the lookahead distance. Because, we are dealing with numbers, the formalism is very strict.

\begin{itemize}
\item 
et-#VAL_P#-#VAL_I#-#VAL_D# : edit throttle PID value
\item
ea-#VAL_P#-#VAL_I#-#VAL_D# :  edit aileron PID value
\item
er-#VAL_P#-#VAL_I#-#VAL_D# : edit rudder PID value
\item
ee-#VAL_P#-#VAL_I#-#VAL_D# : edit elevator PID value
\item
l-#VAL_Lookahead# : edit look ahead distance
\end{itemize}

with \begin{itemize}
\item
  #VAL_P# sould be remplace by the value of the PROPORTIONAL gain 
\item
  #VAL_I# sould be remplace by the value of the INTEGRALE gain 
\item
  #VAL_D# sould be remplace by the value of the DERIVATE gain 
\item
  #VAL_Lookahead# sould be remplace by the value of the wished Look ahead distance 
\end{itemize}

Note: In the code, it is possible to change the separtation charactere. We have chosen '-' but it might be modify by changing the defined value \textsf{separation_char} in \textsf{API\_perso.h}.

Here are some example to understand how it works:

\begin{itemize}
\item 
et-1.56-2.55-0 : edit throttle PID with the proportional gain equal to 1.56, the integrale gain equal to 1.56 and the derivate gain equal to 0
\item
ea-7.01-0.55-0.22 : edit aileron PID with the proportional gain equal to 7.01, the integrale gain equal to 0.55 and the derivate gain equal to 0.22
\end{itemize}

In the code, the function \textsf{API\_interpretate\_chain} cares for the interpretation of the user commands and the instruction transfer.

\bigskip

It is also to mention, that we introduced two time signals, the \textsl{hardware time} and the \textsl{relative time}.
The hardware time is the time since the start-up of the aircraft controller whilst relative time measures the time passed since the last restart of the aircraft in the simulation environment.
A restart brings back the aircraft to the initial position position on the start field, and thus we make sure to reset the desired path plus the relative time, too, in order to bring back the system to a initial state without the need to reset the controller.
In the code, this functionality is implemented in lines 164--178 in \textsf{Autopilot.pde}.

\medskip




\subsection{Path Generation}

Path generation is connected with the user interface. By typing in certain commands in programs such as \texttt{hterm}, we could assign different acrobatic gestures to the plane. 

Trajectories are designed in function~\textsf{Trajectory}. The idea of designing a trajectory is calculating out the desired postion of the plane 1 second later from the actual position of the aircraft, using the function below:
\begin{equation}
\vec{L}_{is}^i = \vec{P}_{des}^i - \vec{P}_{is}^i
\end{equation}
And by using the $\vec{L}_{is}^i$ vector, we could control the aircraft like dragging the string of a kite.

Currently we have 9 different acrobatic gestures. They are divided into two categories, one stable flight paths and the other temoprary flight gestures.

\subsubsection*{Stable gestures}
Stable flight gestures serve as kind of default flying states, they are maintained when undisturbed, can be also interrupted at any time by other flying modes. To choose from different gestures, we can type in the API interface the following commands:

\texttt{'fg'}: glide or go-straight mode. Speed is set to 50 in the forward (or Y) direction.

\texttt{'fb'}: back glide mode. Speed is set to 50 in the backward (or -Y) direction.

\texttt{'fc'}: circle mode. Testing radius is 70, can be changed in function~\textsf{Trajectory}. It has a slight going up speed of 1 to avoid crashing when manoeuvring at a low altitude.

\texttt{'fs'}: snake mode. Now tested is a gesture that goes forward (Y direction), and has a left/right snake sinusoidal turns in X direction. Radius is set to 50.

\subsubsection*{Temporal acrobatic gestures}

Thest gestures are temporal ones, which have certain durations and executed from beginning till end. Afterwards the aircraft changes into default flying states -like fly forward or backward. Commands for them are:

\texttt{'ft'}: takeoff mode. In this mode the plane has a relatively low climb rate for a safe takeoff.

\texttt{'fl'}: looping mode. The plane performs a backward-direction loop by first climbing up and flipping over. A whole barrel loop can be achieved by two backward-direction looping. 

\texttt{'fr'}: roll mode. The plane rolls over 360 degrees for one time in this mode. The plane finishes rolling in two steps, each turn is 180 degrees.

\texttt{'fh'}: half-circle mode. The aircraft flies a half-circle, which would be easier for a downward looping and then flies straight forward.

\texttt{'fc'}: climb up mode. Takeoff mode has a too low climb rate, in this mode climb rate is bigger for a quicker climb up.

These acrobatic flight durations are defined and can be changed in function~\textsf{Trajectory}. In each gesture's sub-function, parameters such as speed, climb rate or roll speed can also be changed.

\medskip

\subsection{Processing of Control Variables}

\subsubsection*{Processing the Sensor Data}

\subsubsection*{Computing the Desired Acceleration}

Introduce look ahead distance, explain, why important -> $L_is$ is always > 0 and ensures a good acceleration command

\subsubsection*{Determining the Desired Speed}\label{ch-Determ-Desired-Speed}

The desired speed of the aircraft is given implicitly with the desired path and can be gathered by calculating the derivative of $\vec{P}_{des}^i$:
\begin{equation}
\vec{v}_{Path}^i(t_k) = \frac{\vec{P}_{des}^i(t_k)-\vec{P}_{des}^i(t_{k-1})}{\Delta T}\quad .
\end{equation}

But the desired speed is not the control variable of the throttle controller. As shown in Figure~\ref{fig_complete_structure}, the input for the throttle controller is $\Delta L$ which is the distance of the aircraft from the desired position with respect to the look-ahead distance~$L_{des}$ and is computed by
\begin{equation}
\Delta L = \frac{\vec{v}_{Path}^i \cdot \vec{L}_{is}^i}{|\vec{v}_{Path}^i|}-L_{des} = L_{is,Path}-L_{des} \quad .
\end{equation}
Here, $L_{is,Path}$ is the distance of the aircraft concerning/on the desired flight direction expressed in $\vec{v}_{Path}^i$.
This relation is shown graphically in \textbf{Figure~\ref{fig_explanation-diagram-throttle}}. The inner structure of the component \texttt{Path Delay} is depicted in \textbf{Figure~\ref{fig_Path_Delay}}.
Finally, $\Delta L$ is divided by a constant value~$K$ and handed to the throttle controller as input $e_{Throttle}$ (see Figure~\ref{fig_Control-Structure}).

\begin{figure}[bth]
  \begin{center}
  	\includegraphics[width=9cm]{pictures/explanation-diagram-throttle.pdf}
  \end{center}
  \caption{Determination of the input for the throttle-controller $\Delta L$.}
  \label{fig_explanation-diagram-throttle}
\end{figure}

\begin{figure}[tbh]
  \begin{center}
  	\includegraphics[width=14cm]{pictures/Path_Delay.pdf}
  \end{center}
  \caption{Inner structure of the component \texttt{Path Delay}.}
  \label{fig_Path_Delay}
\end{figure} 

With this control mechanism, the aircraft will adjust the throttle in order to always stay behind the desired position by the length of the look ahead distance~$L_{des}$ which is the intersection of the desired flight direction~$\vec{v}_{Path}^i$ and the circle of $L_{des}$ as shown in Figure~\ref{fig_explanation-diagram-throttle}. In this point, $\Delta L$ will become zero, which is the control target of the control structure (of course, the whole tangent of the intersection point will meet the control target of $\Delta L = 0$ but the rest of the control structure will force the aircraft onto the desired path and thus to this one intersection point).  

\medskip





\subsection{Control Structure}

In the \texttt{Control Structure}, the four actuators of the aircraft, namely throttle, aileron, rudder, and elevator, are regulated by PID-controllers with an error~$E$ as input value:
\begin{equation}
output(t) = K_p \cdot E(t) + K_i \cdot \int_{t_0}^t E(\tau)\, \mathrm{d}\tau + K_d \cdot \frac{\mathrm{d}}{\mathrm{d}t}E(t)\quad .
\end{equation}

\subsubsection*{Throttle}
The input error of the throttle is the sum of current aircraft velocity~$|\vec{V}^v|$ and the distance of the aircraft~$e_{Throttle}$, lagging behind its desired position, as described in Section~\ref{ch-Determ-Desired-Speed}:
\begin{equation}
E_{throttle} = |\vec{V}^v| + e_{Throttle} \quad .
\end{equation} 
The aircraft velocity term is for keeping the engine speed at the desired level, only the error term can increase or decrease the engine speed.

\subsubsection*{Aileron}
The aileron controller is implemented as described in the work of S.~Park\cite[p.~71]{Park.2012}.
A reference vector~$\hat{e}_{roll}$, always pointing out of the roof of the aircraft, is compared with the acceleration command~$\vec{A}_{CMD}^b$. 
The control target is to let both vectors point into the same direction (this is shown graphically in the paper of S.~Park on page~70~\cite{Park.2012}.
Mathematically, this is achieved with following equation:
\begin{equation}
E_{aileron}=\arcsin\left(\hat{e}_{roll} \times \frac{\vec{A}_{CMD}^b}{|\vec{A}_{CMD}^b|}\right)_x
\end{equation}
The reference vector~$\hat{e}_{roll}$ can be modified by the angle~$\phi_{ref}$. At the value of $\phi_{ref}=90\degree$, $\hat{e}_{roll}$ is pointing out of the right wing of the aircraft; at $\phi_{ref}=180\degree$, the reference vector is pointing out of the fuselage.
Altering the angle of the reference vector can be used for performing a roll manoeuvre.

\subsubsection*{Rudder and Elevator}
Rudder and elevator are controlled with the acceleration command~$\vec{a}_{CMD}^b$, which does not contain the gravity term~$\vec{g}^b$.
The rudder control takes the y-component as input, and the elevator control uses the z-component:
\begin{equation}
E_{rudder}=(\vec{a}_{CMD}^b)_y\quad , \quad E_{elevator} = (\vec{a}_{CMD}^b)_z
\end{equation}

The \texttt{Control Structure} is depicted in symbolic form in \textbf{Figure~\ref{fig_Control-Structure}}.

\begin{figure}[tbh]
  \begin{center}
  	\includegraphics[width=15cm]{pictures/PID.pdf}
  \end{center}
  \caption{Inner structure of the component \texttt{Control Structure}.}
  \label{fig_Control-Structure}
\end{figure}


\medskip






\subsection{GPS Signal Estimation}

In the case of an inverted flight attitude, a GPS-signal cannot be received due to GPS receivers not pointing to the sky.
Therefore, the position of the aircraft has to be estimated with signals from measuring instruments, still available, which is the data from accelerometers and gyroscopes.
However, in the simulation, position data is always provided perfectly, so an inverted flight attitude has first to be detected and position signals have then to be ignored in order to realise a \textsl{real} GPS-signal.

\smallskip

So, the function~\textsf{NoSignalAvailableGPS} is implemented, observing the euler angles of the aircraft, wherewith the flight attitude of the aircraft is depicted.
As soon as the roll angle~$phi$ or pitch angle~$\theta$ is according to amount greater than $60\degree$, this function activates the \textsl{position estimation} which overwrites the ideal position signals.

\smallskip

The \textsl{position estimation}-principle, implemented in the function \textsf{estimateStateVars}, is a method of integration \cite{Dantsker.2016}.
First, the derivatives of the Euler angles are computed with the available rotation rates by changing the coordinate frame. 
Then, the Euler-derivatives are time-step integrated with the previous values to obtain the new Euler angles, e.g.:
\begin{equation}\label{eq-integration}
 \phi_{t_k} = \frac{1}{2}(\dot{\phi}_{t_k}+\dot{\phi}_{t_{k-1}})\cdot \Delta T + \phi_{t_k} \quad .
\end{equation}

In the next step, the acceleration of the aircraft is depicted with the data of the accelerometer~$A$ plus data of the rotation rates~$pqr$, where $\mathbf{C_r}$ offsets the location of the IMU and $\mathcal{R}_b^i$ is the transformation from body frame to inertial frame:
\begin{equation}
\ddot{P^i}(t_k)= \mathcal{R}_b^i(\phi,\theta,\psi)(t_k)\cdot A(t_k) + \mathbf{C_r} \cdot \left[ pqr(t_k) \times uvw(t_{k-1})\right] \quad .
\end{equation}
Here, $uvw$ is the velocity of the aircraft in body frame:
\begin{equation}
uvw(t_k) = \mathcal{R}_i^b(\phi,\theta,\psi)(t_k) \cdot \dot{P^i}(t_k) \quad .
\end{equation}

With the same time-step integration method as shown in Equation~\ref{eq-integration}, the aircraft-velocity, and with a further integration step, the position of the aircraft can be obtained:
\begin{equation}
\ddot{P^i} \rightarrow \dot{P^i} \rightarrow P^i \quad .
\end{equation}

\smallskip

As soon as the aircraft is able to receive a GPS-signal again, the estimation is switched off and the ideal position data is used.


\medskip





\section{Results}\label{ch-Results}


In summary, the presented and implemented control structure showed very good results for various aerobatic manoeuvres which are shown in the following.

\subsubsection*{Restraints}

But beforehand, it is to mention that the rudder was not activated as the results were recorded.
The reason was a faulty adapter software which caused a disconnection with the controller after a few seconds of flight. Instead, we used a stable working adapter software which did not support the control of the rudder.

Also, the GPS signal estimation could not be activated due to imprecise estimation results.
The reasons were the lack of information about the used units of the measurement data and the position of the accelerometers in the aircraft which has to be considered in a compensation term.

\subsubsection*{Analysis of flown Trajectories}

In this project, we also adopted Matlab to help us analyse our flown trajectories. What we wanted is a 3D recording of the real flown trajectory, with this it is easier to find out possible errors in control or path parameter designs.

Matlab code and results are stored in analysis part. Basically we compare 3 sets of data recorded from program \texttt{hterm}: desired path, real trajectory and $\vec{L}_{is}^i$ vector. By dragging around the 3D \textsf{fig} format plot in Matlab we can have a direct notion of how the aircraft had flown and also changes in $\vec{L}_{is}^i$ vector.

\begin{figure}[!ht]
  \centering
  	\includegraphics[width=12cm]{pictures/Results/Circle-desired.jpg}
  	\includegraphics[width=12cm]{pictures/Results/Circle-real.jpg}
  \caption{Comparison of desired and real trajectories of circle flights.}
  \label{fig_circle}
\end{figure}

Here shown in \textbf{Figure~\ref{fig_circle}} are plots with the circle mode. The desired path is shown above and the real trajectory is underneath. We can see that the aircraft adjusted itself to the sharp turn quickly and followed the desired path quite accurate. The takeoff part and glide flight are also flown desirably according to the recorded plot.

\begin{figure}[!ht]
  \centering
  	\includegraphics[width=12cm]{pictures/Results/snake-desired.jpg}
  	\includegraphics[width=12cm]{pictures/Results/snake-real.jpg}
  \caption{Comparison of desired and real trajectories of snake flights.}
  \label{fig_snake}
\end{figure}			



For the snake flight also, here we tested the left/right sinusoidal turns in \textbf{Figure~\ref{fig_snake}}. In coordinates this corresponds to sinusoidal changes in X directions. Similarily, the aircraft had adjusted itself for the first few seconds and then followed the previously designed path.

\begin{figure}[!ht]
  \centering
  	\includegraphics[width=12cm]{pictures/Results/roll-desired.jpg}
  	\includegraphics[width=12cm]{pictures/Results/roll-real.jpg}
  \caption{Comparison of desired and real trajectories of rolling flights.}
  \label{fig_roll}
\end{figure}		

Rolling are shown in \textbf{Figure~\ref{fig_roll}}. We first designed a straight path and then performed the acrobatic rolling. During rolling, the aircraft would inevitably fly off-course a bit, especially when the rolling is performed at a lower rate. It is also proven from the plot, the plane did the full roll in two steps and then adjusted itself to the desired straight path again.

A very important parameter to reassure that the plane would follow the desired path is the look ahead distance $L_{des}$. If $L_{des}$ is too large, and the designed path is not a straight line, the plane would probably fly randomly or even finally crash. A reasonable short $L_{des}$ can provide good responses of the plane when changing courses.

\bigskip






% Textende
%----------------------------------------------------------------
%----------------------------------------------------------------
% Anhang

\newpage

\begin{appendix}
%\renewcommand{\refname}{A}
\section{Appendix}

\bigskip



% Literatur
% ===========================================
\subsection{References}

\begin{flushleft}
\renewcommand{\refname}{}
\singlespacing
%\bibliography{references}
{\def\section*#1{}\bibliography{references}}
\end{flushleft}

%\newpage


\bigskip

\subsection{Notation}

\begin{tabbing}
	 \hspace{2cm} \= \hspace{2cm} \= \hspace{3cm} \kill
	\> $t_k$ \> Point in time (time-discrete)\\	
	\> $\Delta T$ \> Time period of one time step of the system\\
	\> $\phi_{ref}$ \> Angle of reference vector for aileron control, forces the roll-angle\\
	\> $\vec{P}_{des}^i$ \> Desired position of the aircraft (inertial frame)\\
	\> $\vec{P}_{is}^i$ \> Actual position of the aircraft (inertial frame)\\
	\> $\vec{L}_{is}^i$ \> Difference between desired and actual position (inertial frame)\\
	\> $\vec{a}_{CMD}^v$ \> Desired Acceleration of the aircraft (vehicle frame)\\
	\> $\vec{g}^{v,b}$ \> Acceleration by gravity (vehicle,body frame)\\
	\> $\vec{A}_{CMD}^{v,b}$ \> Desired Acceleration with gravity considered (vehicle,body frame)\\
	\> $L_{des}$ \> Look-ahead distance \\
	\> $L_{is,Path}$ \> Distance concerning the desired path, the aircraft lags behind \\
	\> $\Delta L$ \> Desired distance the aircraft needs to catch up \\
	\> $e_{Throttle}$ \> Input error for the throttle controller \\
	\> $(\phi,\theta,\psi)$ \> Euler angles of the aircraft \\
	\> $\vec{V}^v$ \> Velocity vector of the aircraft (vehicle frame)\\	
	
\end{tabbing}


\end{appendix}

\end{document}


% -------------------Bausteine--------------------------------------
	
%\begin{figure}[!b]
%  \begin{center}
%    \includegraphics[width=16cm]{../Machine-Epsilon-different-divisors.eps}
%  \end{center}
%  \caption{\small Figure caption. To get a figure to span two
%      columns, use the environment figure* rather than figure.}
%  \label{fig-label}
%\end{figure}


%\begin{enumerate}[{(\arabic{enumi})}]
%
%	\item
%			
%\end{enumerate}

%\begin{pspicture}[xAxisLabel=Auslastung,yAxisLabel=Herst.-Kosten](-0.5,0)(0.5,6.5)
%\begin{psgraph}[arrows=->,Dx=1,Dy=2](0,0)(-0.1,-0.1)(1.2,1.2){5cm}{4cm}
%	\psplot[plotpoints=200,linecolor=red]{0.075}{1}{0.2 0.1 x add div}
%\end{psgraph}
%\end{pspicture}

%\begin{figure}[ph]
%	\centering
%	\caption{Function with three different solvers for task~2.}
%	\lstinputlisting{../Solver.m}
%	\label{Code-Solver}
%\end{figure}

	
%\section{Literature}
%
%\renewcommand{\refname}{}
%
%\begin{flushleft}
%
%\singlespacing
%\bibliography{references}
%
%\end{flushleft}

%\begin{figure}[ph]
%	\centering
%	\subfloat[Forward Euler]{
%		\includegraphics[width=7.5cm]{../02-FE.eps}
%	}
%	\hfill
%	\subfloat[Symplectic Euler]{
%		\includegraphics[width=7.5cm]{../02-SE.eps}
%	}
%	\\
%	\centering
%	\subfloat[Stormer-Verlet]{
%		\includegraphics[width=7.5cm]{../02-SV.eps}
%	}
%	\hfill
%	\subfloat[Monat November]{
%		\includegraphics[width=7.5cm]{../02-err.eps}
%	}
%	\hfill
%	\caption{Solutions of the computed methods in task~2.}
%	\label{02}
%\end{figure}

%\renewcommand{\arraystretch}{1.4}
%\begin{table}[ht]
%\caption{Simulierte Szenarien.}
%\centering
%\begin{tabular}{R{5cm}|cc}
%\toprule 
%\textbf{Größe} & \textbf{Formelzeichen} & \textbf{Einheit} \\
%\midrule
%\textbf{Strahlungsfluss} & $\Phi_e$ & $\SI{}{\watt}$ \\
%\textbf{Bestrahlungsstärke} & $E_e = \frac{\mathrm d \Phi_e}{\mathrm d A}$ & $\SI{}{\watt \per \square \meter}$ \\
%\textbf{Lichtstrom} & $\Phi$ & $\SI{}{\lumen}$ \\
%\textbf{Beleuchtungsstärke} & $L = \frac{\mathrm d \Phi}{\mathrm d A}$ & $\SI{}{\lux} = \SI{}{\lumen \per \square \meter}$ \\
%\textbf{Lichtausbeute} & $K = \frac{\Phi}{P}$ & $\SI{}{\lumen \per \watt}$ \\
%\bottomrule 
%\end{tabular}
%\label{tab:groessen-einheiten}
%\end{table}
%\renewcommand{\arraystretch}{1.0}
